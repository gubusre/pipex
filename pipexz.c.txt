#include "pipex.h"
static void	free_array(char **arr)
{
int	i;
i = 0;
while (arr[i])
free(arr[i++]);
free(arr);
}
void	exec_cmd(char *cmd_str, char **envp)
{
char	**args;
char	*path;
args = ft_split(cmd_str, ' ');
if (!args)
exit(1);
path = find_path(args[0], envp);
if (!path)
{
free_array(args);
perror("Command not found");
exit(127);
}
execve(path, args, envp);
free(path);
free_array(args);
perror("execve");
exit(1);
}
char	*find_path(char *cmd, char **envp)
{
char	**paths;
char	*path_str;
char	*candidate;
int		i;
if (cmd[0] == '/' || (cmd[0] == '.' && cmd[1] == '/'))
if (access(cmd, X_OK) == 0)
return (ft_strdup(cmd));
i = 0;
while (envp[i] && ft_strncmp(envp[i], "PATH=", 5) != 0)
i++;
if (!envp[i])
return (NULL);
path_str = envp[i] + 5;
paths = ft_split(path_str, ':');
i = 0;
while (paths[i])
{
candidate = ft_strjoin(paths[i], "/");
candidate = ft_strjoin(candidate, cmd); // Note: this overwrites, better to implement proper join with free
if (access(candidate, X_OK) == 0)
{
free_array(paths);
return (candidate);
}
free(candidate);
i++;
}
free_array(paths);
return (NULL);
}
int	main(int argc, char **argv, char **envp)
{
int	fd_in;
int	fd_out;
int	pipefd[2];
pid_t	pid1;
pid_t	pid2;
if (argc != 5)
{
write(2, "Usage: ./pipex infile cmd1 cmd2 outfile\n", 40);
exit(1);
}
fd_in = open(argv[1], O_RDONLY);
if (fd_in < 0)
{
perror(argv[1]);
exit(1);
}
fd_out = open(argv[4], O_CREAT | O_WRONLY | O_TRUNC, 0644);
if (fd_out < 0)
{
perror(argv[4]);
close(fd_in);
exit(1);
}
if (pipe(pipefd) == -1)
{
perror("pipe");
close(fd_in);
close(fd_out);
exit(1);
}
pid1 = fork();
if (pid1 == -1)
{
perror("fork");
exit(1);
}
if (pid1 == 0)
{
close(pipefd[0]);
dup2(fd_in, STDIN_FILENO);
close(fd_in);
dup2(pipefd[1], STDOUT_FILENO);
close(pipefd[1]);
exec_cmd(argv[2], envp);
}
close(fd_in);
close(pipefd[1]);
pid2 = fork();
if (pid2 == -1)
{
perror("fork");
exit(1);
}
if (pid2 == 0)
{
close(pipefd[1]);
dup2(pipefd[0], STDIN_FILENO);
close(pipefd[0]);
dup2(fd_out, STDOUT_FILENO);
close(fd_out);
exec_cmd(argv[3], envp);
}
close(pipefd[0]);
close(fd_out);
waitpid(pid1, NULL, 0);
waitpid(pid2, NULL, 0);
return (0);
}
// Helper functions
char	*ft_strdup(const char *s1)
{
char	*dest;
int		i;
dest = malloc(ft_strlen(s1) + 1);
if (!dest)
return (NULL);
i = 0;
while (s1[i])
{
dest[i] = s1[i];
i++;
}
dest[i] = '\0';
return (dest);
}
size_t	ft_strlen(const char *s)
{
size_t	i;
i = 0;
while (s[i])
i++;
return (i);
}
int	ft_strncmp(const char *s1, const char *s2, size_t n)
{
size_t	i;
i = 0;
while (i < n && s1[i] && s2[i])
{
if (s1[i] != s2[i])
return ((unsigned char)s1[i] - (unsigned char)s2[i]);
i++;
}
if (i < n)
return ((unsigned char)s1[i] - (unsigned char)s2[i]);
return (0);
}
char	*ft_strjoin(char const *s1, char const *s2)
{
char	*new;
int		i;
int		j;
new = malloc(ft_strlen(s1) + ft_strlen(s2) + 1);
if (!new)
return (NULL);
i = 0;
while (s1[i])
{
new[i] = s1[i];
i++;
}
j = 0;
while (s2[j])
{
new[i + j] = s2[j];
j++;
}
new[i + j] = '\0';
return (new);
}
char	**ft_split(char const *s, char c)
{
int		words;
char	**res;
const char	*start;
int		i;
int		len;
words = 0;
start = s;
while (*s)
{
if (*s == c)
s++;
else
{
words++;
while (*s && *s != c)
s++;
}
}
res = malloc(sizeof(char *) * (words + 1));
if (!res)
return (NULL);
i = 0;
s = start;
while (*s)
{
while (*s == c)
s++;
if (*s)
{
start = s;
while (*s && *s != c)
s++;
len = s - start;
res[i] = malloc(len + 1);
if (!res[i])
{
while (i--)
free(res[i]);
free(res);
return (NULL);
}
strncpy(res[i], start, len);
res[i][len] = '\0';
i++;
}
}
res[i] = NULL;
return (res);
}